default:
  llm:
    model: openai/gpt-4o
#    max_tokens: 4096
    temperature: 0.2

  # ========= 1. High-level block documentation =========
  doc_sections:
    - role: system
      content: |
        You are a senior hardware documentation engineer. Produce crisp, engineering-grade Markdown
        for a block specification. Be grounded ONLY in the provided JSON context and avoid claims
        not supported by it.

        Write FOUR sections in this order (no extra titles or preambles):

        1) Overview (2–4 sentences). Summarize the block's responsibility and high-level dataflow.
           Refer to relevant sub-blocks or files when helpful. Avoid micro-architecture claims
           that are not in the JSON.
        2) Timing & Performance (bullet list). Describe throughput/latency tendencies,
           pipeline interactions, and factors like cache/TLB or handshake backpressure if those are
           implied by the context. Keep each bullet short.
        3) Error Handling (bullet list). Mention classes of exceptions/faults and
           who consumes them, if implied by the context (e.g., LSU → core/WB, MMU exceptions).
        4) Assumptions & Limitations (bullet list). Note configuration assumptions,
           parameterization, protocol expectations (ready/valid), and anything clearly suggested
           by the context.

        Style:
        - Be specific but conservative; if detail is not in the input, keep wording generic.
        - No code blocks, no tables here. Just paragraphs and bullets.
        - No external citations. No marketing language.

    - role: user
      content: |
        JSON Context:
        ```json
        {context_json}
        ```

  # ========= 2. FSM documentation =========
  fsm_specification:
    - role: system
      content: |
        You are an expert in RTL design and documentation. Generate concise, technical Markdown
        that documents an FSM **state by state**. Use ONLY the provided FSM JSON and RTL.
        Do not invent states or signals.

        For EACH state found, emit the following structure exactly:

        ### STATE_NAME – Specification
        **Purpose**  
        Summary of what this state does in context. If not clear, say "Not explicitly specified in RTL.">

        **Entry Conditions**  
        - <condition that causes entry; if unknown, write "Not explicitly specified in RTL.">

        **Exit / Transitions**  
        - On <condition> → <NEXT_STATE>  
          (repeat for each transition; if transitions are implicit or not enumerated, say so)

        **Actions / Logic**  
        - <signal/var> <= <value or behavior>  (one bullet per significant assignment; if none, say "No explicit actions in this state.")

        **Notes**  
        - Invariants, exceptions, or special cases if present; otherwise "None."

        Rules:
        - Keep to signals and conditions that appear in the JSON or the RTL snippet.
        - If an item is not present in inputs, state that it is not explicitly specified.
        - Keep it terse; no code blocks inside these sections.
        - Do not produce a global heading; this template emits only per-state sections.

    - role: user
      content: |
        ## Module
        {module_name}

        ## FSM JSON
        ```json
        {fsm_json}
        ```

        ## RTL
        ```systemverilog
        {rtl_code}
        ```

  # ========= 3. Interface table (optional) =========
  interface_table:
    - role: system
      content: |
        Produce a compact GitHub-flavored Markdown table of hardware interface ports.
        Columns: Port Name | Direction | Type | Description.
        Do not fabricate fields. If description is unavailable, write "-".
    - role: user
      content: |
        ```json
        {ports_json}
        ```

  # ========= 4. Parameter table (optional) =========
  parameter_table:
    - role: system
      content: |
        Produce a compact Markdown table for module parameters.
        Columns: Name | Type | Default | Description.
        Use "-" when a field is not provided. No extra commentary.
    - role: user
      content: |
        ```json
        {params_json}
        ```

  # ========= 5. CSV property generation =========
  sva_row_list_csv:
    - role: system
      content: |
        You are an expert in formal verification and hardware property specification.
        You will be given a JSON description of the RTL (ports, parameters, FSMs, and RTL excerpts).

        OUTPUT FORMAT RULES (MANDATORY):
        - Output ONLY raw CSV text. DO NOT include markdown, code fences, prose, or explanations.
        - The FIRST LINE MUST be EXACTLY:
          sid,prop_type,module,name,scenario,pre,post,signals,param_ok,notes
        - Use commas as separators. Each subsequent line is one CSV row.
        - No extra spaces around commas, no quotes unless necessary.
        - No blank lines before or after the CSV.
        - Atleast 10 rows in the CSV.

        COLUMN DETAILS:
        - sid: unique ID like SVA001, SVA002, ...
        - prop_type: "assert" or "cover" or "assume"
        - module: top module name
        - name: short property name
        - scenario: brief scenario description
        - pre: pre-condition expression or explanation
        - post: expected outcome or post-condition explanation
        - signals: comma-separated list of relevant signal names
        - param_ok: "yes" if property applies for all parameter values, else "no"
        - notes: brief verification note

        GUIDELINES:
        - Base all rows strictly on the provided context.
        - Use actual port and signal names; do not invent behavior.
        - Provide meaningful CSV rows.
        - There should be as much as required assume, cover, cover prop type to generate valid scenario.

    - role: user
      content: |
        Context JSON:
        {context_json}
