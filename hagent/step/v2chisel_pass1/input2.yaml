llm:
  # model: "fireworks_ai/accounts/fireworks/models/llama-v3p2-3b-instruct"
  model: "openai/gpt-4-turbo-preview"

threshold: 0
context: 2

verilog_original: |
  // Generated by CIRCT firtool-1.62.0
  // Standard header to adapt well known macros for register randomization.
  `ifndef RANDOMIZE
    `ifdef RANDOMIZE_REG_INIT
      `define RANDOMIZE
    `endif // RANDOMIZE_REG_INIT
  `endif // not def RANDOMIZE

  // RANDOM may be set to an expression that produces a 32-bit random unsigned value.
  `ifndef RANDOM
    `define RANDOM $random
  `endif // not def RANDOM

  // Users can define INIT_RANDOM as general code that gets injected into the
  // initializer block for modules with registers.
  `ifndef INIT_RANDOM
    `define INIT_RANDOM
  `endif // not def INIT_RANDOM

  // If using random initialization, you can also define RANDOMIZE_DELAY to
  // customize the delay used, otherwise 0.002 is used.
  `ifndef RANDOMIZE_DELAY
    `define RANDOMIZE_DELAY 0.002
  `endif // not def RANDOMIZE_DELAY

  // Define INIT_RANDOM_PROLOG_ for use in our modules below.
  `ifndef INIT_RANDOM_PROLOG_
    `ifdef RANDOMIZE
      `ifdef VERILATOR
        `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
      `else  // VERILATOR
        `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
      `endif // VERILATOR
    `else  // RANDOMIZE
      `define INIT_RANDOM_PROLOG_
    `endif // RANDOMIZE
  `endif // not def INIT_RANDOM_PROLOG_

  // Include register initializers in init blocks unless synthesis is set
  `ifndef SYNTHESIS
    `ifndef ENABLE_INITIAL_REG_
      `define ENABLE_INITIAL_REG_
    `endif // not def ENABLE_INITIAL_REG_
  `endif // not def SYNTHESIS

  // Include rmemory initializers in init blocks unless synthesis is set
  `ifndef SYNTHESIS
    `ifndef ENABLE_INITIAL_MEM_
      `define ENABLE_INITIAL_MEM_
    `endif // not def ENABLE_INITIAL_MEM_
  `endif // not def SYNTHESIS

  module Counter( // src/main/scala/Counter.scala:7:9
    input        clock,   // src/main/scala/Counter.scala:7:9
                 reset,   // src/main/scala/Counter.scala:7:9
                 io_enable,       // src/main/scala/Counter.scala:8:16
                 io_reset,        // src/main/scala/Counter.scala:8:16
    output [3:0] io_count // src/main/scala/Counter.scala:8:16
  );

    reg [3:0] countReg;   // src/main/scala/Counter.scala:15:27
    always @(posedge clock) begin // src/main/scala/Counter.scala:7:9
      if (reset)  // src/main/scala/Counter.scala:7:9
        countReg <= 4'h0; // src/main/scala/Counter.scala:15:27
      else if (io_reset)  // src/main/scala/Counter.scala:8:16
        countReg <= 4'h0; // src/main/scala/Counter.scala:15:27
      else if (io_enable) // src/main/scala/Counter.scala:8:16
        countReg <= countReg + 4'h1;      // src/main/scala/Counter.scala:15:27, :21:28
    end // always @(posedge)
    `ifdef ENABLE_INITIAL_REG_    // src/main/scala/Counter.scala:7:9
      `ifdef FIRRTL_BEFORE_INITIAL        // src/main/scala/Counter.scala:7:9
        `FIRRTL_BEFORE_INITIAL    // src/main/scala/Counter.scala:7:9
      `endif // FIRRTL_BEFORE_INITIAL
      initial begin       // src/main/scala/Counter.scala:7:9
        automatic logic [31:0] _RANDOM[0:0];      // src/main/scala/Counter.scala:7:9
        `ifdef INIT_RANDOM_PROLOG_        // src/main/scala/Counter.scala:7:9
          `INIT_RANDOM_PROLOG_    // src/main/scala/Counter.scala:7:9
        `endif // INIT_RANDOM_PROLOG_
        `ifdef RANDOMIZE_REG_INIT // src/main/scala/Counter.scala:7:9
          _RANDOM[/*Zero width*/ 1'b0] = `RANDOM; // src/main/scala/Counter.scala:7:9
          countReg = _RANDOM[/*Zero width*/ 1'b0][3:0];   // src/main/scala/Counter.scala:7:9, :15:27
        `endif // RANDOMIZE_REG_INIT
      end // initial
      `ifdef FIRRTL_AFTER_INITIAL // src/main/scala/Counter.scala:7:9
        `FIRRTL_AFTER_INITIAL     // src/main/scala/Counter.scala:7:9
      `endif // FIRRTL_AFTER_INITIAL
    `endif // ENABLE_INITIAL_REG_
    assign io_count = countReg;   // src/main/scala/Counter.scala:7:9, :15:27
  endmodule


verilog_fixed: |
  // Generated by CIRCT firtool-1.62.0
  // Standard header to adapt well known macros for register randomization.
  `ifndef RANDOMIZE
    `ifdef RANDOMIZE_REG_INIT
      `define RANDOMIZE
    `endif // RANDOMIZE_REG_INIT
  `endif // not def RANDOMIZE

  // RANDOM may be set to an expression that produces a 32-bit random unsigned value.
  `ifndef RANDOM
    `define RANDOM $random
  `endif // not def RANDOM

  // Users can define INIT_RANDOM as general code that gets injected into the
  // initializer block for modules with registers.
  `ifndef INIT_RANDOM
    `define INIT_RANDOM
  `endif // not def INIT_RANDOM

  // If using random initialization, you can also define RANDOMIZE_DELAY to
  // customize the delay used, otherwise 0.002 is used.
  `ifndef RANDOMIZE_DELAY
    `define RANDOMIZE_DELAY 0.002
  `endif // not def RANDOMIZE_DELAY

  // Define INIT_RANDOM_PROLOG_ for use in our modules below.
  `ifndef INIT_RANDOM_PROLOG_
    `ifdef RANDOMIZE
      `ifdef VERILATOR
        `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
      `else  // VERILATOR
        `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
      `endif // VERILATOR
    `else  // RANDOMIZE
      `define INIT_RANDOM_PROLOG_
    `endif // RANDOMIZE
  `endif // not def INIT_RANDOM_PROLOG_

  // Include register initializers in init blocks unless synthesis is set
  `ifndef SYNTHESIS
    `ifndef ENABLE_INITIAL_REG_
      `define ENABLE_INITIAL_REG_
    `endif // not def ENABLE_INITIAL_REG_
  `endif // not def SYNTHESIS

  // Include rmemory initializers in init blocks unless synthesis is set
  `ifndef SYNTHESIS
    `ifndef ENABLE_INITIAL_MEM_
      `define ENABLE_INITIAL_MEM_
    `endif // not def ENABLE_INITIAL_MEM_
  `endif // not def SYNTHESIS

  module Counter( // src/main/scala/Counter.scala:7:9
    input        clock,   // src/main/scala/Counter.scala:7:9
                 reset,   // src/main/scala/Counter.scala:7:9
                 io_enable,       // src/main/scala/Counter.scala:8:16
                 io_reset,        // src/main/scala/Counter.scala:8:16
    output [3:0] io_count // src/main/scala/Counter.scala:8:16
  );

    reg [3:0] countReg;   // src/main/scala/Counter.scala:15:27
    always @(posedge clock) begin // src/main/scala/Counter.scala:7:9
      if (reset)  // src/main/scala/Counter.scala:7:9
        countReg <= 4'h0; // src/main/scala/Counter.scala:15:27
      else if (io_reset)  // src/main/scala/Counter.scala:8:16
        countReg <= 4'h0; // src/main/scala/Counter.scala:15:27
      else if (io_enable) // src/main/scala/Counter.scala:8:16
        countReg <= countReg - 4'h1;      // src/main/scala/Counter.scala:15:27, :21:28
    end // always @(posedge)
    `ifdef ENABLE_INITIAL_REG_    // src/main/scala/Counter.scala:7:9
      `ifdef FIRRTL_BEFORE_INITIAL        // src/main/scala/Counter.scala:7:9
        `FIRRTL_BEFORE_INITIAL    // src/main/scala/Counter.scala:7:9
      `endif // FIRRTL_BEFORE_INITIAL
      initial begin       // src/main/scala/Counter.scala:7:9
        automatic logic [31:0] _RANDOM[0:0];      // src/main/scala/Counter.scala:7:9
        `ifdef INIT_RANDOM_PROLOG_        // src/main/scala/Counter.scala:7:9
          `INIT_RANDOM_PROLOG_    // src/main/scala/Counter.scala:7:9
        `endif // INIT_RANDOM_PROLOG_
        `ifdef RANDOMIZE_REG_INIT // src/main/scala/Counter.scala:7:9
          _RANDOM[/*Zero width*/ 1'b0] = `RANDOM; // src/main/scala/Counter.scala:7:9
          countReg = _RANDOM[/*Zero width*/ 1'b0][3:0];   // src/main/scala/Counter.scala:7:9, :15:27
        `endif // RANDOMIZE_REG_INIT
      end // initial
      `ifdef FIRRTL_AFTER_INITIAL // src/main/scala/Counter.scala:7:9
        `FIRRTL_AFTER_INITIAL     // src/main/scala/Counter.scala:7:9
      `endif // FIRRTL_AFTER_INITIAL
    `endif // ENABLE_INITIAL_REG_
    assign io_count = countReg;   // src/main/scala/Counter.scala:7:9, :15:27
  endmodule

chisel_original: |
  // Import Chisel library
    import chisel3._
    import chisel3.util._
    
    // Define the Counter module
    class Counter extends Module {
      val io = IO(new Bundle {
        val enable = Input(Bool())
        val reset  = Input(Bool())
        val count  = Output(UInt(4.W))
      })
    
      // Initialize the count register
      val countReg = RegInit(0.U(4.W))
    
      // Define the counter behavior
      when (io.reset) {
        countReg := 0.U
      } .elsewhen (io.enable) {
        countReg := countReg + 1.U
      }
    
      // Connect the count register to the output
      io.count := countReg
    }
    
    // Generate the Verilog code
    object CounterDriver extends App {
      emitVerilog(new Counter())
    }


name: counter

