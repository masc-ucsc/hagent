[
  {
    "id": "6269ae11-9b17-434d-9778-4e8a347c18bb",
    "content": "Fix the sorting algorithm implementation bugs in Python.",
    "context": "Python algorithm debugging",
    "importance_score": 1.0,
    "retrieval_count": 0,
    "timestamp": "202504241539",
    "last_accessed": "",
    "category": "Python",
    "faulty_code": "#!/usr/bin/env python3\n\"\"\"Simple buggy sorting algorithm implementation\"\"\"\n\nimport random\n\ndef buggy_bubble_sort(arr):\n    \"\"\"Bubble sort with intentional bugs\"\"\"\n    n = len(arr)\n    \n    # Bug 1: Range should be n, not n-1 (misses last pass)\n    for i in range(n-1):\n        # Bug 2: Range should be n-i-1, not n-1 (unnecessarily checks sorted elements)\n        for j in range(n-1):\n            # Bug 3: Inconsistent swap direction (sorts in descending order)\n            if arr[j] < arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    return arr\n\n# Test the buggy sorting function\ntest_array = [random.randint(1, 100) for _ in range(10)]\nprint(f\"Original array: {test_array}\")\nprint(f\"Sorted array: {buggy_bubble_sort(test_array.copy())}\")\n# Bug 4: Original array shows as sorted in output due to modifying the array directly ",
    "fixed_code": "#!/usr/bin/env python3\n\"\"\"Simple buggy sorting algorithm implementation\"\"\"\n\nimport random\n\ndef buggy_bubble_sort(arr):\n    \"\"\"Bubble sort with intentional bugs fixed\"\"\"\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    return arr\n\n# Test the buggy sorting function\ntest_array = [random.randint(1, 100) for _ in range(10)]\nprint(f\"Original array: {test_array}\")\nprint(f\"Sorted array: {buggy_bubble_sort(test_array.copy())}\")",
    "compiler_errors": [
      "Warning: Potential off-by-one error in array indexing"
    ],
    "language": "python",
    "created_at": "2025-04-24T15:39:26.852763",
    "keywords": [
      "Python",
      "sorting",
      "algorithm",
      "bug",
      "bubble sort"
    ],
    "tags": [
      "python",
      "algorithms",
      "debugging"
    ],
    "links": []
  },
  {
    "id": "b576f5f3-40ee-4410-9968-ab9455e712a5",
    "content": "Fix memory management issues in this C++ array implementation.",
    "context": "C++ memory management",
    "importance_score": 1.0,
    "retrieval_count": 0,
    "timestamp": "202504241539",
    "last_accessed": "",
    "category": "C++",
    "faulty_code": "#include <iostream>\n\n// Buggy array implementation with several issues\nclass BuggyArray {\nprivate:\n    int* arr;\n    int size;  // Bug 1: Should track capacity separately from size\n    \npublic:\n    BuggyArray(int capacity) {\n        arr = new int[capacity];\n        size = capacity;  // Bug 2: Size should be initialized to 0\n    }\n    \n    // Bug 3: Missing destructor - memory leak\n    \n    void set(int index, int value) {\n        arr[index] = value;  // Bug 4: No bounds checking\n    }\n    \n    int get(int index) {\n        return arr[index];  // Bug 5: No bounds checking\n    }\n};\n\nint main() {\n    BuggyArray arr(5);\n    arr.set(10, 100);  // Bug: Out of bounds access\n    std::cout << \"Value: \" << arr.get(10) << std::endl;  // Bug: Out of bounds access\n    return 0;  // Bug: Memory leak (no destructor)\n} ",
    "fixed_code": "#include <iostream>\n\nclass BuggyArray {\nprivate:\n    int* arr;\n    int size;\n    int capacity;\n\npublic:\n    BuggyArray(int capacity) : capacity(capacity), size(0) {\n        arr = new int[capacity];\n    }\n    \n    ~BuggyArray() {\n        delete[] arr;\n    }\n    \n    void set(int index, int value) {\n        if (index >= 0 && index < capacity) {\n            arr[index] = value;\n            if (index >= size) size = index + 1;\n        }\n    }\n    \n    int get(int index) {\n        if (index >= 0 && index < size) {\n            return arr[index];\n        }\n        return -1; // Or throw an exception or handle error appropriately\n    }\n};\n\nint main() {\n    BuggyArray arr(5);\n    arr.set(0, 100);  // Fixed: Access within bounds\n    std::cout << \"Value: \" << arr.get(0) << std::endl;  // Fixed: Access within bounds\n    return 0;\n}",
    "compiler_errors": [
      "Warning: Potential memory leak - allocating memory without proper cleanup"
    ],
    "language": "cpp",
    "created_at": "2025-04-24T15:39:26.852763",
    "keywords": [
      "C++",
      "memory leak",
      "array",
      "bug",
      "destructor"
    ],
    "tags": [
      "cpp",
      "memory management",
      "debugging"
    ],
    "links": []
  },
  {
    "id": "f8add829-3e14-4433-bb44-68aaffa2fcf3",
    "content": "Fix the reset logic in this Verilog counter module.",
    "context": "Debugging Verilog modules",
    "importance_score": 1.0,
    "retrieval_count": 0,
    "timestamp": "202504241539",
    "last_accessed": "",
    "category": "Verilog",
    "faulty_code": "// Buggy Verilog Counter with intentional bugs\nmodule buggy_counter(\n    input clk,\n    input reset_n,\n    output reg [3:0] count,\n    output reg overflow\n);\n    // Bug 1: Missing output type (should be reg overflow)\n    \n    // Bug 2: Using negedge instead of posedge\n    always @(negedge clk) begin\n        // Bug 3: Missing reset logic\n        \n        // Counter logic with overflow bug\n        if (count == 4'b1111) begin\n            count <= 0;\n            overflow = 1;  // Bug 4: Using blocking assignment\n        end else begin\n            count <= count + 1;\n            overflow = 0;  // Bug 4: Using blocking assignment\n        end\n    end\nendmodule ",
    "fixed_code": "// Fixed Verilog Counter\nmodule buggy_counter(\n    input clk,\n    input reset_n,\n    output reg [3:0] count,\n    output reg overflow\n);\n\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            count <= 0;\n            overflow <= 0;\n        end else if (count == 4'b1111) begin\n            count <= 0;\n            overflow <= 1;\n        end else begin\n            count <= count + 1;\n            overflow <= 0;\n        end\n    end\nendmodule",
    "compiler_errors": [
      "%Warning-DECLFILENAME: /var/folders/33/2m8c0r8s1cq6tfdwpfpy9ycc0000gn/T/tmpv4a0heru.v:2:8: Filename 'tmpv4a0heru' does not match MODULE name: 'buggy_counter'",
      "%Error: Exiting due to 1 warning(s)"
    ],
    "language": "verilog",
    "created_at": "2025-04-24T15:39:26.852763",
    "keywords": [
      "Verilog",
      "counter",
      "reset",
      "bug",
      "hardware"
    ],
    "tags": [
      "verilog",
      "hardware",
      "debugging"
    ],
    "links": []
  }
]